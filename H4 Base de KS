import numpy as np
from pyscf import gto, dft

mol = gto.M(atom=f"H 0 0 -0.74; H 0 0 0.74; H 0.74 0 0; H -0.74 0 0",
                basis="sto-3g",
                unit="Angstrom",
                verbose = 0
                )

energia_nuclear = mol.energy_nuc()


mf = dft.RKS(mol)
mf.xc = 'b3lyp'
mf.kernel()

hcore = mf.get_hcore()
n = hcore.shape[0]
eri_ao = mol.intor('int2e')
eri_ao_flat = eri_ao.reshape(n**2, n**2)  # 2x2 = 4
C = mf.mo_coeff

np.savetxt(f"integral_1e_H4.txt", hcore, fmt="%.10f")
np.save(f"integral_2e_H4.npy",eri_ao)
np.savetxt(f"coef_KS_H4.txt", C, fmt="%.10f")

////////////////////////////////////////////////////////////////////////////////

import numpy as np

h_ao = np.loadtxt("integral_1e_H4.txt")  # 2x2 #Base atomica
eri_ao_flat = np.load("integral_2e_H4.npy") #Base atômica
C = np.loadtxt(f"coef_KS_H4.txt")

#eri_ao = eri_ao_flat.reshape(4, 4, 4, 4)
h_mo = C.T @ h_ao @ C

g_mo = np.zeros((4, 4, 4, 4))

for i in range(4):
    for j in range(4):
        for k in range(4):
            for l in range(4):
                for p in range(4):
                    for q in range(4):
                        for r in range(4):
                            for s in range(4):
                                g_mo[i, j, k, l] += (
                                C[p, i] * C[r, k] *
                                eri_ao[p, r, q, s] *
                                C[q, j] * C[s, l]
                                )


np.savetxt("h_mo_H4.txt", h_mo, fmt="%.10f")
np.save("g_mo_H4.npy", g_mo)

//////////////////////////////////////////////////////////////////////////////////////////


import numpy as np
from qiskit_nature.second_q.operators import FermionicOp
from qiskit_nature.second_q.mappers import JordanWignerMapper
from qiskit_algorithms import VQE
from qiskit.circuit.library import EfficientSU2
from qiskit.primitives import Estimator
from qiskit_algorithms.optimizers import COBYLA
from qiskit.algorithms.optimizers import L_BFGS_B
from qiskit.opflow import PauliSumOp
from qiskit.algorithms.optimizers import L_BFGS_B
from pyscf import gto


mol = gto.M(atom=f"H 0 0 -0.74; H 0 0 0.74; H 0.74 0 0; H -0.74 0 0",
                basis="sto-3g",
                unit="Angstrom"
                )

energia_nuclear = mol.energy_nuc()

h_ks = np.loadtxt(f"h_mo_H4.txt")
g_ks = np.load(f"g_mo_H4.npy")

n_orb = h_ks.shape[0]

n_spin_orb = 2 * n_orb

    # --- Termo de 1 elétron --- com a adição dos orbitais de spin
h1_dict = {}
for p in range(n_spin_orb):
      for q in range(n_spin_orb):
        if (p % 2) == (q % 2):
            i, j = p // 2, q // 2
            val = h_ks[i, j]
            if abs(val) > 1e-10:
                h1_dict[f"+_{p} -_{q}"] = val

h1 = FermionicOp(h1_dict, num_spin_orbitals=n_spin_orb)

# --- Termo de 2 elétrons --- com a adição dos orbitais de spin
h2_dict = {}
for p in range(n_spin_orb):
    for q in range(n_spin_orb):
        for r in range(n_spin_orb):
            for s in range(n_spin_orb):
                if (p % 2 == r % 2) and (q % 2 == s % 2):
                    i, j, k, l = p // 2, q // 2, r // 2, s // 2
                    val = g_ks[i, j, k, l]
                    if abs(val) > 1e-10:
                        h2_dict[f"+_{p} +_{q} -_{s} -_{r}"] =  0.5 * val

h2 = FermionicOp(h2_dict, num_spin_orbitals=n_spin_orb)

fermionico_op = h1 + h2

mapper = JordanWignerMapper()
qubit_op = mapper.map(fermionico_op)

#VQE
ansatz = EfficientSU2(num_qubits=qubit_op.num_qubits, reps = 1, entanglement = 'full')

vqe = VQE(
    Estimator(),
    ansatz=ansatz,
    optimizer=COBYLA(maxiter = 400),
    initial_point=[0.0] * ansatz.num_parameters
)

vqe_resultado = vqe.compute_minimum_eigenvalue(qubit_op)
energia_eletronica = vqe_resultado.eigenvalue.real
total_energy = energia_eletronica + energia_nuclear


print("\nEnergia eletrônica (VQE):", energia_eletronica)
print("Energia nuclear:", energia_nuclear)
print("Energia total (VQE):", total_energy)
